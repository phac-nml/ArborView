<!DOCTYPE html>
<html>
<head>
    <style>
        .inline-block-child {
            display: inline-block;
        }

        .scrollbar-window{
            overflow: auto;
            /*overflow-x: scroll;*/
            /*height: 200px;*/
        }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Random colour library for creating some nice highlighted trees    -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/randomcolor/0.6.1/randomColor.min.js" integrity="sha512-vPeZ7JCboHcfpqSx5ZD+/jpEhS4JpXxfz9orSvAPPj0EKUVShU2tgy7XkU+oujBJKnWmu4hU7r9MMQNWPfXsYw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- Below switching to tidy tree 0.5.1 as the dev broke 0.5.0 -->

    <script rel="stylesheet" type="text/javascript" href="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css">
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.js"></script>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script type="text/javascript" src="https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js"></script>

    <!--toggle buttons by https://palcarazm.github.io/bootstrap5-toggle/ -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap5-toggle@5.0.4/css/bootstrap5-toggle.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap5-toggle@5.0.4/js/bootstrap5-toggle.ecmas.min.js"></script>


    <script type="text/javascript">
        //var test_newick = "((BGIOSIFCE006902.1_ORYSA:0.652945[&&NHX:S=ORYSA],(At4g19560.1_ARATH:0.566484[&&NHX:S=ARATH],(At4g19600.1_ARATH:0.229647[&&NHX:S=ARATH],At5g45190.1_ARATH:0.149569[&&NHX:S=ARATH]):0.109796[&&NHX:S=ARATH:SIS=100:D=Y:B=100]):0.283052[&&NHX:S=ARATH:SIS=100:D=Y:B=100]):0.930921[&&NHX:S=Magnoliophyta:D=N:B=100],((((((((((((CCNK_HUMAN:0.001351[&&NHX:S=HUMAN],CCNK_F3_PANTR:0.001588[&&NHX:S=PANTR]):0.009317[&&NHX:S=Homo/Pan/Gorilla_group:D=N:B=100],CCNK_MACMU:0.01227[&&NHX:S=MACMU]):0.020339[&&NHX:S=Catarrhini:D=N:B=100],(CCNK_BOVIN:0.049478[&&NHX:S=BOVIN],CCNK_CANFA:0.076883[&&NHX:S=CANFA]):0.026972[&&NHX:S=Laurasiatheria:D=N:B=97]):0.01376[&&NHX:S=Eutheria:D=N:B=62],(Ccnk_MOUSE:0.018183[&&NHX:S=MOUSE],LOC500715_RAT:0.02728[&&NHX:S=RAT]):0.054247[&&NHX:S=Murinae:D=N:B=100]):0.087752[&&NHX:S=Eutheria:D=N:B=65],CCNK_MONDO:0.069457[&&NHX:S=MONDO]):0.053263[&&NHX:S=Theria:D=N:B=83],NP_001026380_CHICK:0.085022[&&NHX:S=CHICK]):0.059401[&&NHX:S=Amniota:D=N:B=80],CCNK_XENTR:0.175799[&&NHX:S=XENTR]):0.075577[&&NHX:S=Tetrapoda:D=N:B=97],((si_dkey-60a16_F2_BRARE:0.143195[&&NHX:S=BRARE],(CCNK_TETNG:0.142629[&&NHX:S=TETNG],CCNK_F2_GASAC:0.115749[&&NHX:S=GASAC]):0.130837[&&NHX:S=Percomorpha:D=N:B=100]):0.077038[&&NHX:S=Clupeocephala:D=N:B=95],ENSGACT00000017400_GASAC:0.40355[&&NHX:S=GASAC]):0.058401[&&NHX:S=Clupeocephala:SIS=33:D=Y:B=13]):0.233994[&&NHX:S=Euteleostomi:D=N:B=18],(ENSCINT00000017473_CIOIN:0[&&NHX:S=CIOIN],ENSCINT00000026852_CIOIN:0.002343[&&NHX:S=CIOIN]):0.481407[&&NHX:S=CIOIN:SIS=100:D=Y:B=100]):0.090892[&&NHX:S=Chordata:D=N:B=98],((CycK-RA_DROME:0.17719[&&NHX:S=DROME],dper_GLEANR_8777_caf1_DROPE:0.174477[&&NHX:S=DROPE]):0.199588[&&NHX:S=Sophophora:D=N:B=100],(AAEL013531-RA_AEDAE:0.214131[&&NHX:S=AEDAE],XP_317464_ANOGA:0.204436[&&NHX:S=ANOGA]):0.178396[&&NHX:S=Culicidae:D=N:B=100]):0.293157[&&NHX:S=Diptera:D=N:B=100]):0.104694[&&NHX:S=Coelomata:D=N:B=98],Smp_130980_SCHMA:0.624197[&&NHX:S=SCHMA]):0.041513[&&NHX:S=Bilateria:D=N:B=84],(WBGene00009650_CAEEL:0.186775[&&NHX:S=CAEEL],(CBG04574_CAEBR:0.21279[&&NHX:S=CAEBR],cr01.sctg48.wum.67.1_CAERE:0.192611[&&NHX:S=CAERE]):0.076335[&&NHX:S=Caenorhabditis:D=N:B=86]):1.18006[&&NHX:S=Caenorhabditis:D=N:B=86]):0.311276[&&NHX:S=Bilateria:D=N:B=84])[&&NHX:S=Eukaryota:D=N:B=0];";
        var NEWICK = null;
        var tree_root = null;
        var METADATA = null;
        var TABLE_HEADERS = null;
        var data_table = null;
        var original_data = null;
        var query_table = null;
        var ORIGINAL_DATA = null;
        var ORIGINAL_VIEW_BOX = null;
        var ORIGINAL_WIDTH_SVG = 0;  
        var LAST_MOVE_X = 0;
        var LAST_MOVE_Y = 0;
        var collapse_subtree = false; // can think of another way to signal state without our larger refactor 
        var focused_element = null; // Focused element to have its colour reset
        const colour_legend = new Array;
        const default_color = "#999";
        const clicked_color = "blue";
        const ID_FIELD = 0;
        const SELECTED_NODES = new Set();
        const right_mouse = 3;
        const center_mouse = 2;
        const left_mouse = 1;

        /** Code for parsing a newick tree to be used by D3
         * The code is taken from Knhx.js written by Heng Li
        */

        

        function kn_new_node() { // private method
            // Heng li code to add node
            return {parent:null, children:[], name:"", meta:"", d:-1.0, hl:false, hidden:false};
        }

        function kn_add_node(str, l, tree, x) // private method
        {
            // Heng Li code to add nodes to a tree
            var r, beg, end = 0, z;
            z = kn_new_node();
            for (i = l, beg = l; i < str.length && str.charAt(i) != ',' && str.charAt(i) != ')'; ++i) {
                var c = str.charAt(i);
                if (c == '[') {
                    var meta_beg = i;
                    if (end == 0) end = i;
                    do ++i; while (i < str.length && str.charAt(i) != ']');
                    if (i == str.length) {
                        tree.error |= 4;
                        break;
                    }
                    z.meta = str.substr(meta_beg, i - meta_beg + 1);
                } else if (c == ':') {
                    if (end == 0) end = i;
                    for (var j = ++i; i < str.length; ++i) {
                        var cc = str.charAt(i);
                        if ((cc < '0' || cc > '9') && cc != 'e' && cc != 'E' && cc != '+' && cc != '-' && cc != '.')
                            break;
                    }
                    z.d = parseFloat(str.substr(j, i - j));
                    --i;
                } else if (c < '!' && c > '~' && end == 0) end = i;
            }
            if (end == 0) end = i;
            if (end > beg) z.name = str.substr(beg, end - beg);
            tree.node.push(z);
            return i;
        }
    
        function kn_parse(str)
            {
                // Heng li Newick parsing code
            var stack = new Array();
            var tree = new Object();
            tree.error = tree.n_tips = 0;
            tree.node = new Array();
            for (var l = 0; l < str.length;) {
                while (l < str.length && (str.charAt(l) < '!' || str.charAt(l) > '~')) ++l;
                if (l == str.length) break;
                var c = str.charAt(l);
                if (c == ',') ++l;
                else if (c == '(') {
                    stack.push(-1); ++l;
                } else if (c == ')') {
                    var x, m, i;
                    x = tree.node.length;
                    for (i = stack.length - 1; i >= 0; --i)
                        if (stack[i] < 0) break;
                    if (i < 0) {
                        tree.error |= 1; break;
                    }
                    m = stack.length - 1 - i;
                    l = kn_add_node(str, l + 1, tree, m);
                    for (i = stack.length - 1, m = m - 1; m >= 0; --m, --i) {
                        tree.node[x].children[m] = tree.node[stack[i]];
                        tree.node[stack[i]].parent = tree.node[x];
                    }
                    stack.length = i;
                    stack.push(x);
                } else {
                    ++tree.n_tips;
                    stack.push(tree.node.length);
                    l = kn_add_node(str, l, tree, 0);
                }
            }
            if (stack.length > 1) tree.error |= 2;
            tree.root = tree.node[tree.node.length - 1];
            return tree;
        }
        //~~~~~~~~~ End of Heng Li's Code


        let CreateMenuItem = (node_type, text, evt_list_func, on_click) => {
            // TODO in refactor pass object
            let node = document.createElement(node_type);
            // TODO pass object of default values
            if(node_type !== "h4"){ // Not liking the way this is formatted
                node.style.cursor = "default";
            }
            node.style.margin = "2px";
            node.innerHTML = text;
            if(evt_list_func !== undefined){
                evt_list_func(node);
            }
            if(on_click !== undefined){
                node.onclick = on_click;
            }
            return node;
        }

        let ColourMouseOver = (node) => {
            // TODO can probably make an object to do all this
            node.addEventListener("mouseenter", (event) => {
                event.target.style.backgroundColor = "LightSalmon";
            });
            node.addEventListener("mouseleave", (event) => {
                    event.target.style.backgroundColor = "";
            });
        };

        let AppendToParent = (parent, ...nodes) => {
            nodes.forEach(arg => parent.appendChild(arg));
        };

        let CreateDropDownDiv = (event) => {
            const div_height_adj = 5;
            let drop_down_menu = document.createElement("div");
            drop_down_menu.style.background = "white";
            drop_down_menu.style.position = "absolute";
            drop_down_menu.style.left = event.x+'px';
            drop_down_menu.style.top = (event.y - div_height_adj)+'px';
            drop_down_menu.style.borderStyle = "solid";
            drop_down_menu.style.borderWidth = "2px";
            drop_down_menu.style.backgroundColor = "linen";
            drop_down_menu.setAttribute("id", "PopDownMenu");
            drop_down_menu.addEventListener("click", (event) => {
                drop_down_menu.remove();
            });
            drop_down_menu.addEventListener("mouseleave", (event) => {
                event.target.remove();
            });
            return drop_down_menu;
        }

        let NodeDropDownMenu = (event, data, func) => {
            // Rendering dropdown menu on click, it may be better to render a hidden menu for each node in a div
            // This would clutter the dom however
            console.log("NodeDropDownMenu()")
            if(event.target.parentNode.classList.contains("inner-node")){
                let drop_down_menu = CreateDropDownDiv(event);
                let title = CreateMenuItem("h4", "Node Options");

                let collapse_tree = CreateMenuItem("p", "Collapse/Un-collapse branch", ColourMouseOver, func);

                // TODO need to remove selected nodes when drawing subtree
                let create_subtree = CreateMenuItem("p", "Display Sub-tree", ColourMouseOver, () => {
                    CustomSubTree(event, data);
                });

                let select_child_nodes = CreateMenuItem("p", "Select all Children", ColourMouseOver, () => {
                    SelectChildren(event, data);
                });

                AppendToParent(drop_down_menu, title, collapse_tree, create_subtree, select_child_nodes);            
                document.body.appendChild(drop_down_menu);
            }else{
                LeafNode(event, data);
                // TODO refactor function name
                updated_nodes();
            }
        };

        // Tree specific code for this project implementation
        let CustomSubTree = (event, data) => {
            SELECTED_NODES.clear();
            updated_nodes();
            $("#TreeData").empty();
            if(data !== null){
                let svg_chart = chart(data.data);
                $("#TreeData").append(svg_chart);
            }
        };

        // Helper function to recurse through child nodes
        let RecurseTree = (data) => {
            let children = new Array;
            let ids = new Array;
            children.push(...data._children);
            while (children.length){
                let child = children.pop();
                if(!child._children){
                    ids.push(child.data.name);
                }else{
                    children.push(...child._children)
                }
            }
            return ids;
        };

        // Select all children of an inner-node
        let SelectChildren = (event, data) => {
            const circle_pos = 1;
            const trg_name_pos = 2;
            let selected_children = RecurseTree(data);
            let selceted_children_jq = `#TreeSVG #${selected_children.join(", #TreeSVG #")}`;
            $(`${selceted_children_jq}`).each((i, d) => {
                SELECTED_NODES.add(d.id);
                let child_nodes = d.childNodes;
                child_nodes[circle_pos].fill = clicked_color;
                child_nodes[trg_name_pos].style.fontWeight = "bold";
                child_nodes[trg_name_pos].style.fill = "black";
            })
            updated_nodes();

        };


        let LeafNode = (event, d) => {
            d.children = d.children ? null : d._children;
            const circle_pos = 1;
            const trg_name_pos = 2;
            let parent = event.target.closest('g').childNodes;
            let trg = parent[circle_pos];
            let node_name = parent[trg_name_pos].innerHTML;
            if(!d._children){
                if(trg.style.fill === clicked_color){
                    trg.style.fill = default_color;
                    parent[trg_name_pos].style.fontWeight = "normal";
                    parent[trg_name_pos].style.fill = "black";
                    // TODO perhaps move this to its own function (class would be preferable)
                    // So that when nodes are appended the legend updates and colours nodes
                    SELECTED_NODES.delete(node_name);
                }else{
                    trg.style.fill = clicked_color;
                    parent[trg_name_pos].style.fontWeight = "bold";
                    parent[trg_name_pos].style.fill = "black";
                    SELECTED_NODES.add(node_name);
                }
            }
        };

        // D3.js Tidy Tree code
        // Modified but taken from: https://observablehq.com/@d3/collapsible-tree
        // Specify the charts’ dimensions. The height is variable, depending on the layout.
        const chart = (data) => {
                // Specify the charts’ dimensions. The height is variable, depending on the layout.
                //console.log(window.innerWidth);
                //console.log(window.innerHeight);
                //const width = 2000;
                
                const width = window.innerWidth;
                const marginTop = 40;
                const marginRight = 10;
                const marginBottom = 10;
                const marginLeft = 40;

                // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
                // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
                // “bottom”, in the data domain. The width of a column is based on the tree’s height.
                const root = d3.hierarchy(data);
                const dx = 20;
                const dy = (width - marginRight - marginLeft) / (1 + root.height);

                // Define the tree layout and the shape for links.
                const tree = d3.tree().nodeSize([dx, dy]);
                const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

                // Create the SVG container, a layer for the links and a layer for the nodes.
                const svg = d3.create("svg")
                    .attr("id", "TreeSVG")
                    .attr("width", width)
                    .attr("height", dx)
                    //.call(d3.zoom().on("zoom", function () {
                    //    svg.attr("transform", d3.zoomTransform(this))
                    //}))
                    //.attr("viewBox", [0, -dx, width, dx])
                    //.attr("viewBox", [0, -marginTop, width, dx])
                    .attr("style", `width:${width}px; height: auto; font: 10px sans-serif; user-select: none;`)
                     
                  

                const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.4)
                    .attr("stroke-width", 1.5);

                const gNode = svg.append("g")
                    .attr("cursor", "pointer")
                    .attr("pointer-events", "all");
                

                function update(event, source) {
                    //$("#TestSubTree").append(chart(source));
                    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                    const nodes = root.descendants().reverse();
                    const links = root.links();

                    // Compute the new tree layout.
                    tree(root);

                    let left = root;
                    let right = root;
                    root.eachBefore(node => {
                        if (node.x < left.x) left = node;
                        if (node.x > right.x) right = node;
                    });


                    ORIGINAL_WIDTH_SVG=width
                    const height = right.x - left.x + marginTop + marginBottom;
                    const transition = svg.transition()
                        .duration(duration)
                        .attr("height", height)
                        .attr("viewBox", [0, left.x - marginTop, width, height])
                        //.attr("viewBox", [0, left.x - marginTop, width, height])
                        //.attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
                        .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));
                    
                    
                        
                    //svg.call(d3.zoom()
                    //    .extent([[0, 0], [width, height]])
                    //    .scaleExtent([1, 8])
                    //    .on("zoom", zoomed));
                    
                    //svg.call(d3.zoom().on("zoom", () => {
                    //    svg.attr("transform", d3.event.transform)
                    //}));
                    


                    // Update the nodes…
                    const node = gNode.selectAll("g")
                        .data(nodes, d => d.id);

                    // Enter any new nodes at the parent's previous position.
                    const nodeEnter = node.enter().append("g")
                        .attr("transform", d => `translate(${source.y0},${source.x0})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0)
                        .attr("id", (d) => {
                            if(d.data.name){
                                return d.data.name;
                            }
                        })
                        .attr("class", (d) => {
                            if(!d.children){
                                return "tree-node leaf-node";
                            }
                            return "tree-node inner-node";
                        })
                        .on("mousedown", (event, d) => {
                            console.log(event.which)
                            d.children = d.children ? null : d._children;
                            if(event.which == left_mouse){
                                // Likely have to move dropdown logic here
                                // TODO add functionality for if subtree is collapsed and contains selected nodes
                                // that those nodes are dropped from the selection and the legend is updated
                                NodeDropDownMenu(event, d, () => {
                                    update(event, d);
                                });
                            }
                        });

                    nodeEnter.append("circle")
                        .attr("r", 2.5)
                        .attr("fill", d => d._children ? "#555" : "#999")
                        .attr("stroke-width", 10);

                    nodeEnter.append("text")
                        .attr("dy", "0.31em")
                        .attr("x", d => d._children ? -6 : 6)
                        .attr("text-anchor", d => d._children ? "end" : "start")
                        .text(d => d.data.name)
                        .clone(true).lower()
                        .attr("stroke-linejoin", "round")
                        .attr("stroke-width", 3)
                        .attr("stroke", "white");

                    // Transition nodes to their new position.
                    const nodeUpdate = node.merge(nodeEnter).transition(transition)
                        .attr("transform", d => `translate(${d.y},${d.x})`)
                        .attr("fill-opacity", 1)
                        .attr("stroke-opacity", 1);

                    // Transition exiting nodes to the parent's new position.
                    const nodeExit = node.exit().transition(transition).remove()
                        .attr("transform", d => `translate(${source.y},${source.x})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0);

                    // Update the links…
                    const link = gLink.selectAll("path")
                        .data(links, d => d.target.id);

                    // Enter any new links at the parent's previous position.
                    const linkEnter = link.enter().append("path")
                        .attr("d", d => {
                            const o = {x: source.x0, y: source.y0};
                            return diagonal({source: o, target: o});
                        });

                    // Transition links to their new position.
                    link.merge(linkEnter).transition(transition)
                        .attr("d", diagonal);

                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition(transition).remove()
                        .attr("d", d => {
                            const o = {x: source.x, y: source.y};
                            return diagonal({source: o, target: o});
                        });

                    // Stash the old positions for transition.
                    root.eachBefore(d => {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                }

                // Do the first update to the initial configuration of the tree — where a number of nodes
                // are open (arbitrarily selected as the root, plus nodes with 7 letters).
                root.x0 = dy / 2;
                root.y0 = 0;
                root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
                // ! Removed below block to open the whole tree at once
                //if (d.depth && d.data.name.length !== 7) d.children = null;
                //if (d.depth && d.data.name.length !== 7) d.children = null;
                });
                
                update(null, root);
                
                return svg.node();
            }
        // ~~~~~~ End of D3.js copy pasted code


        let updated_nodes = () => {
            $("#SelectedNodes").html(function(){
                let attribute = "";
                // TODO need to add event listener so that when list values are clicked they are removed
                for(const item of SELECTED_NODES.keys()){
                    attribute = attribute + `
                        <div class="d-flex border-bottom align-items-center selected-node">
                        <div onclick="scroll_into_view_treenode('${item}')" class="flex-grow-1">${item}</div>
                        <div>
                            <button onclick="delete_sel_node(this)" data-node-id="${item}" class="btn btn-danger m-1 btn-sm">x</button>
                        </div>
                        </div>\n`;
                }
                //attribute = '<ul class="selected-nodes">' + attribute + "</ul>";
                return attribute;
            });
        };

        let drawTree = (newick_) => {
            console.log('render a tree from Newick file')
            let tree = kn_parse(newick_);
            tree_root = tree.root; // Save the trees root to redraw the tree when needed
            let node_out = chart(tree.root);
            $("#TreeData").append(node_out);
            document.querySelector('#SelectedNodes').style.maxHeight = `${document.querySelector('#TreeData').offsetHeight - document.querySelector('#tree_menu_buttons').offsetHeight}px`
            document.querySelector('#TreeData').scrollTo(document.querySelector('#TreeData').scrollWidth/2,0)
        };


        let CreateDataTable = () => {
            data_table = $('#metadata').DataTable({
                stateSave: true,
                className: ".editable",
            });
            // TODO initializing table from json object would minimize copies
            $("td").addClass("editable");
            $("td:not(:first-child)").attr("contenteditable", true);
            // Saving data as a map, to allow for updating of metadata
            ORIGINAL_DATA = new Map();
            data_table.rows().data().each((value, index) => {
                ORIGINAL_DATA.set(value[ID_FIELD], value)
            });
        };


        let CreateTable = (parsed_data, table_id, table_headers) => {
            let headers = table_headers;
            let table_head = "";
            let table_body = [];
            for(const item of headers){
                table_head = table_head + `<th>${item}</th>\n`;
            }
            for(const item of parsed_data){
                table_body.push('<tr>\n');
                for(const header of headers){
                    table_body.push(`<td class="editable">${item[header]}</td>\n`);
                }
                table_body.push("</tr>\n");
            }
            //delete parsed_data;
            parsed_data = null;
            $(table_id).html("<thead>" + table_head + "</thead>" + "<tbody>" + table_body.join() + "</tbody>");
            CreateDataTable();
        };

        // TODO this is dead code and should be removed
        let CreateQueryTable = () => {

            if(SELECTED_NODES.size === 0){
                console.log("No nodes selected!");
                if($.fn.DataTable.isDataTable('#query-data')){
                    // If selections are empty remove the table
                    // Thank you SO for this: https://stackoverflow.com/questions/32713612/jquery-datatables-destroy-re-create
                    $('#query-data').DataTable().destroy();
                    $("#query-data tbody").empty()
                    $("#query-data thead").empty()
                };
                return null;
            }

            let indices = [];
            let data_columns = []
            for(const item of TABLE_HEADERS){
                data_columns.push({title: item});
            }

            data_table.column(ID_FIELD).data().map((value, idx) => {
                if(SELECTED_NODES.has(value)){
                    indices.push(idx);
                }
            });

            // TODO this could be made more performant by check what is new in the set and only getting that data and appending it to the table
            // TODO clearing and adding could be added and would then only require initializing the datatable once
            let selected_data = data_table.rows( indices ).data().toArray();
            if($.fn.DataTable.isDataTable('#query-data')){
                // TODO probably faster to clear the table then add rows
                $('#query-data').DataTable().destroy();
                $("#query-data tbody").empty()
                $("#query-data thead").empty()
            };

            query_table = new DataTable("#query-data", {
                columns: data_columns,
                data: selected_data
            });
        };

        let CreateColoringGroups = (array_vals) => {
            let new_obj = new Object();
            for(const item of array_vals){
                new_obj[item] = new Array;
            }
            return new_obj;
        };

        //fill legend with items
        let CreateNodeLegend = (array_tuples) => {
            let node_leg = $("#colour-legend").empty()
            
            //let node_leg = $("#Legend");
            console.log(node_leg)

            for(const item of array_tuples){
                console.log(item);
                let row_legend_node = $(`<div class="d-flex p-1 border-bottom flex-nowrap align-items-center"></div>`)
                row_legend_node.append(`
                <div style="width: 20px; height:20px; padding: 5px; background-color: ${item[1]}; border: 1px solid black"></div>\n
                <small style="padding-left:5px">${item[0]}</small>`)
                node_leg.append(row_legend_node)
            }
            document.querySelector('#colour-legend').classList.remove("d-none");
            document.querySelector('#colour-legend').style.left = `${document.querySelector('#TreeData').scrollLeft}px`
            //node_leg.append(legend_items_div)
        };

        let PopulateGroups = (json_groups, query_key) => {
            ORIGINAL_DATA.forEach((value, key) => {
                json_groups[value[query_key]].push(key);
            });
            return json_groups;
        };

        let ResetTable = () => {
            data_table.clear();
            // Is there a more space efficient way to do this?
            // TODO perhaps metadata from d3 can be used here
            data_table.rows.add(Array.from(ORIGINAL_DATA.values())).draw();
            $("td").addClass("editable");
            $("td:not(:first-child)").attr("contenteditable", true);
        };

        let SubsetTable = () => {
            let filtered = data_table.data().filter((value, idx) => {
                return SELECTED_NODES.has(value[ID_FIELD]);
            });
            data_table.clear();
            data_table.rows.add(filtered).draw();
            $("td").addClass("editable");
            $("td:not(:first-child)").attr("contenteditable", true);

        };


        $(() => {

            $("#redraw-tree-button").on("click", () => {
                $("#TreeData").empty();
                if(tree_root !== null){
                    $("#TreeData").append(chart(tree_root));
                    return true;
                }
                console.log("No tree to redraw");
                
            });

            // ! Below disables the right click menu for the page
            document.oncontextmenu = (event) => {
                // Disables context menu for TreeData div, e.g. default web menu does not appear
                let item_id = event.target.closest("div").id;
                //if(item_id === "TreeData"){
                //    return false;
                //}
                //if(item_id === "TreeData"){
                //    return false;
                //}
                return true;
            };

            // TODO save me some clicking
            //drawTree(test_newick);

            $("#tree-selector").change((event) => {
                let reader = new FileReader();
                let newick_file = event.target.files[0];
                reader.readAsText(newick_file, "UTF-8");
                reader.onload = (evt) => {
                    newick = evt.target.result;
                    drawTree(newick);
                };
                reader.onerror = (evt) => {
                    alert(`Could not read file ${newick_file}`);
                };
            });

            $("#ResetTree").on("click", (evt) => {
                //let svg = $("#TreeSVG");
                if(focused_element !== null){
                    // Revert any focused node back to its original colours
                    // TODO update colour as a constant
                    // TODO discuss with Kirill if the colour should stay as it may be useful when looking throught the tree
                    // TODO perhaps this should be dropped as there is a redraw tree option
                    focused_element.setAttribute('fill', "black");
                }
                let svg = document.querySelector('#TreeSVG')
                let og_box = svg.getBBox();
                //svg.setAttribute("viewBox", `${og_box.x + og_box.x},${og_box.y},${og_box.width},${og_box.height}`);
                svg.style.width = `${og_box.width}`
                //scroll to middle of the div
                document.querySelector('#TreeData').scrollLeft = document.querySelector('#TreeData').clientWidth/2
            });

            // TODO look up alternative to blur, as only when content is changed does a look up need to be done
            $("#metadata").on("blur", ".editable", (evt)=>{
                // This gives me elemet to look for, just need to update original element with it
                // TODO alter original elements here
                let row_values = evt.target.closest("tr").childNodes;
                console.log(row_values);
                let edited_value = row_values[0].textContent;
                let retrieved_value = ORIGINAL_DATA.get(edited_value);
                for(let i = 0; i < retrieved_value.length; i++){
                    retrieved_value[i] = row_values[i].textContent;

                }
            });

            $("#metadata-selector").change((event) => {
                let reader = new FileReader();
                let metadata_file = event.target.files[0];
                reader.readAsText(metadata_file, "UTF-8");
                reader.onload = (evt) => {
                    let metadata = evt.target.result;
                    METADATA = d3.tsvParse(metadata);
                    TABLE_HEADERS = METADATA.columns;
                    CreateTable(METADATA, "#metadata", TABLE_HEADERS);
                    METADATA = null;
                };
                reader.onerror = (evt) => {
                    alert(`Could not read file ${metadata_file}`);
                };
            });

            $("#metadata-search-button").on('click', SubsetTable);
            $("#reset-table-button").on('click', ResetTable);

            $("#TreeData").on("mousdown", ".leaf-node", (evt) => {
                console.log(evt.which);
            });
            $("#TreeData").on("mousdown", ".inner-node", (evt) => {
                console.log(evt.which);
            });

            // TODO need to change from sorting_1, to  :first
            // Zoom in on a NODE on single click event
            $("#metadata").on('click', 'tr td:first-child', (evt) => {
                console.log(`ZOOMING on node ${evt.target.textContent}`)
                let identified_point = document.querySelector(`#${evt.target.textContent}`)
                let identified_point_id = identified_point.childNodes[0].innerHTML; // gets nodes name
                let is_selected = SELECTED_NODES.has(identified_point_id);
                if(focused_element !== null && !is_selected){
                    // Return elements state unluss it is already adjusted due to being selected 
                    focused_element.setAttribute('fill', "black");
                    
                }
                focused_element = identified_point; // Save reference to new point

                if(!is_selected){
                    // Highlight selected item unless it is already highlighted due to being selected
                    identified_point.setAttribute('fill', 'DodgerBlue');
                }
                let rect = identified_point.getBBox();
                let translated_coords = identified_point.getAttribute('transform').replace('translate(', '').replace(")", '').split(",");
                let rect_x = parseFloat(translated_coords[0]);
                let rect_y = parseFloat(translated_coords[1]);
                console.log(`point x: ${rect_x} y: ${rect_y}`)
                let svg = document.querySelector('#TreeSVG')
                
                //const [original_x,original_y,original_w,original_h] = document.querySelector('#TreeSVG').getAttribute('viewBox').split(',').map(n => {return parseInt(n)})    

                scroll_into_view_treenode(`${evt.target.textContent}`)
                //document.querySelector(`#${evt.target.textContent}`).scrollIntoView({block: "center", inline:"center"})
                
                //add nodes to the selected node list
                SELECTED_NODES.add(`${evt.target.textContent}`)
                updated_nodes()

                //let zoom_zero_viewbox = document.querySelector('#TreeSVG').getAttribute('viewBox')
                //document.querySelector('#TreeSVG').setAttribute('viewBox', '0 0 2000 4775.19921875')
                //let og_box = svg.getBBox()
             
                //let new_view = "" + ((rect.x + rect_x) - (og_box.width * 0.15)) + " " + ((rect.y + rect_y ) - (og_box.height * 0.02)) + " " + og_box.width * 0.5 + " " + og_box.height * 0.5;
                //let new_view = `${rect_x-(svg.clientWidth/2)+100} ${rect_y-200} ${og_box.width/2} ${og_box.height}`
                //console.log(`new_view = ${new_view}`)
                //svg.setAttribute('viewBox', `${rect_x} ${rect_y} ${svg.getAttribute('width')} 2000`)
                //svg.setAttribute("viewBox", new_view);
                
            });


            $("#SelectedNodes").on('dblclick', '.selected-node', delete_sel_node = (evt) => {
                console.log(evt.dataset)
                let node_name = ''
                if (evt.target !== undefined){
                    node_name = evt.target.textContent;
                }else{
                    node_name = evt.dataset.nodeId
                }    
                console.log(node_name)
                SELECTED_NODES.delete(node_name);
                let unselected_data = $(`g #${node_name}`).children();
                console.log(unselected_data)
                unselected_data[1].style.fill = default_color;
                unselected_data[2].style.fontWeight = "normal";
                unselected_data[2].style.fill = "black";
                updated_nodes();
            });

            $("#TreeData").on('scroll', '#TreeSVG', (evt) => {
                console.log("scrolling");
            });

            $("#metadata").on("dblclick", "thead th:not(:first)", (evt) => {
                // TODO add a list of headers somewhere to select colouring from
                let unq_data = data_table.column(evt.target).data().unique();
                let column_index = data_table.column(evt.target)[0];

                // Need to create groupings of the each set of ID's belonging to each value grouping
                let break_down_values = unq_data.toArray();
                
                // Instead of searching the array for ID's using the datatable, I am just going to use a linear look up
                let group_vals = CreateColoringGroups(break_down_values);
                break_down_values = PopulateGroups(group_vals, column_index);
                let colours = randomColor({luminosity: 'dark', count: Object.keys(break_down_values).length, seed: 42});
                
                let colour_idx = 0;
                colour_legend.length = 0; // clear out old data, so new legend created each time
                for(const item in break_down_values){
                    let query_string = `#${break_down_values[item].join(", #")}`;
                    let values_update = $(query_string).children("circle").map((idx, elm) => {
                        elm.style.fill = colours[colour_idx];
                    });
                    colour_legend.push([item, colours[colour_idx]])
                    colour_idx++;
                }
                CreateNodeLegend(colour_legend);    
            });

        });

        zoom_tree = function(){
  
            const zoom_times = parseFloat(document.querySelector('#zoom_slider').value)
            const tree_data_elm = document.querySelector('#TreeData')
            const tree_svg = document.querySelector('#TreeSVG')
            document.querySelector('#zoom_slider_value').textContent =  zoom_times 
            //const original_width = document.querySelector('#TreeSVG').getBBox().width //get original width of the SVG at 1x zoom
            //document.querySelector('#TreeSVG').style.width = width *  zoom_times 
            
         
            const new_width = ORIGINAL_WIDTH_SVG  * zoom_times //use global value as getBBox() at high zooms gives wrong values
            const prev_width = parseFloat(document.querySelector('#TreeSVG').style.width)

            //Previous x and y scroll positions before applying a zoom
            const prev_x_scroll_pos = tree_data_elm.scrollLeft
            const prev_y_scroll_pos = tree_data_elm.scrollTop
            document.querySelector('#TreeSVG').style.width = new_width ; //modify width of SVG tree
            
            //store new translated x and y coordinates after zooming 
            let zoom_x_translated = 0 
            let zoom_y_translated = 0
     
            const scaleChange = new_width/prev_width //sometimes the specified zoom factor is not exact, use this value instead
            
            //keeping zoom centered on an element
            if(new_width > prev_width){
                console.log("zooming in")
                //get previous scroll position which is the left most x-coordinate position of a view
                //translate that coordiante to a new zoomed state
                //add 1/4 view field length scaled to a new zoomed state coordinate
                zoom_x_translated =  prev_x_scroll_pos*scaleChange + (tree_data_elm.clientWidth/4)*(scaleChange)
                zoom_y_translated =  prev_y_scroll_pos*scaleChange + (tree_data_elm.clientHeight/4)*(scaleChange)
      
            
            }else{
                //Zooming out 
                console.log("zooming out")
                //Scale current scroll position (previous scroll + 1/4 view field distance) to a new coordinate zoomed out state
                //Substract the 1/4 offeset/margin that is already in the needed zoomed out state (no adjustments)
                zoom_x_translated =  prev_x_scroll_pos*scaleChange - (tree_data_elm.clientWidth/4)
                zoom_y_translated =  prev_y_scroll_pos*scaleChange - (tree_data_elm.clientHeight/4)
            
            }
            document.querySelector('#TreeData').scrollTo(zoom_x_translated,zoom_y_translated)
        }

        scroll_into_view_treenode = function(id){
            let selectedNode = document.querySelector(`#${id}`)
            if(selectedNode !== null){
             selectedNode.scrollIntoView({block: "center", inline:"center"})
            }else{
                console.log(`scroll_into_view_treenode(): Node ${id} is not available in this tree. Uncollapse all nodes`)
            } 
        }

        legend_on_off = function(node){
            console.log(node.checked)
            if(node.checked === false){
                document.querySelector('#colour-legend').classList.add("d-none")
            }else{
                document.querySelector('#colour-legend').classList.remove("d-none");

            }    
        }

        scroll_legend_into_view = function(node,node_TreeData){
            node.style.left=`${node_TreeData.scrollLeft}px`
            node.style.top=`${node_TreeData.scrollTop}px`
        }



    </script>
</head>
    <body>
        <div class="container-fluid m-0 ">
            <div class="row border">
                <div class="col-3">
                    <label for="tree-selector">Select a Newick File </label>
                </div>
                <div class="col-9">
                    <input type="file" id="tree-selector" name="tree-selector" accept=".nwk, .newick, .treefile"> 
                </div>
            </div>
            <div class="row border ">
                <div class="col-3">
                    <label for="metadata-selector">Select a tab delimited metadata file</label>
                </div>
                <div class="col-9">   
                    <input type="file" id="metadata-selector" name="metadata-selector" accept=".tsv, .tab">
                </div>    
            </div>
          

        
            <div class="row"> <!-- id="TreeSelections" style=""-->

                <div class="position-relative col-10 Tree inline-block-child scrollbar-window" 
                  onscroll="scroll_legend_into_view(document.querySelector('#colour-legend'), this)"
                  id="TreeData" style="height:500px;">
                        <div id="colour-legend" 
                        class="d-none p-1 position-absolute border border-secondary text-break Tree inline-block-child scrollbar-window" 
                        style="top:0px; left:0px; resize: both;">    
                        </div>  
                </div>
                <div class="col-2 border border-primary">
                    <div id="tree_menu_buttons" class="row">
                                <button class="btn btn-primary w-100" name="ResetTree" id="ResetTree">Reset Tree View</button>
                                
                                <!--Zoom slider-->
                                <div class="d-flex flex-wrap align-items-center p-1 text-center">
                                    <span class="flex-grow-1" for="zoom_slider" class="form-label">Zoom</span>
                                
                                    <div class="flex-grow-1 w-50">
                                        <input type="range" class="form-range align-middle"  id="zoom_slider" onchange="zoom_tree()" value="1" min="1" max="5" step="0.5">
                                    </div>
                                    <div class="flex-grow-1 fw-bold">
                                        <span id="zoom_slider_value">1</span>x
                                        
                                    </div>    
                                </div>  
                                
                                <button class="btn btn-primary w-100 text-break mb-1" name="SearchMetadata" id="metadata-search-button">Search Metadata</button>
                                <button class="btn btn-primary w-100 text-break" name="ResetTable" id="reset-table-button">Reset Table</button>
                                <div class="d-flex flex-wrap p-1 align-items-center text-left">
                                    <label class="flex-grow-1" for="legend_toggle">Legend</label>
                                    <input onchange="legend_on_off(this)" id="legend_toggle" checked type="checkbox" data-toggle="toggle" 
                                    data-toggle="toggle" data-onstyle="primary" data-size="sm">
                                </div>    
                    </div> 
                    <div class="row">
                            <div class="col p-1 w-100 border-primary Tree inline-block-child scrollbar-window" id="SelectedNodes"></div>
                    </div> 
 
                </div>
                
            </div>
            
            <div id="ClusterInfo" class="row border border-primary">
                <div class="col-12 overflow-auto">
                    <table id="metadata" class="display overflow-scroll" style="width:100%; height:50vh"></table>
                </div>    
            </div>

             
              
                
                    
                
                <!-- Need to have the legend be scrollable and situated under the selected nodes-->
                
            
        </div> 
        <div id="TestSubTree"></div> 
        

        
    </body>
</html>