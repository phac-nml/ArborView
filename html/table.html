<!DOCTYPE html>
<html>
<head>
    <style>

        .inline-block-child {
            display: inline-block;
        }

        .scrollbar-window{
            overflow: scroll;
            overflow-x: auto;
            /*height: 200px;*/
        }
    </style>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- Below switching to tidy tree 0.5.1 as the dev broke 0.5.0 -->

    <script rel="stylesheet" type="text/javascript" href="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css">
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.js"></script>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script type="text/javascript" src="https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js"></script>


    <script type="text/javascript">
        //var newick = "((BGIOSIFCE006902.1_ORYSA:0.652945[&&NHX:S=ORYSA],(At4g19560.1_ARATH:0.566484[&&NHX:S=ARATH],(At4g19600.1_ARATH:0.229647[&&NHX:S=ARATH],At5g45190.1_ARATH:0.149569[&&NHX:S=ARATH]):0.109796[&&NHX:S=ARATH:SIS=100:D=Y:B=100]):0.283052[&&NHX:S=ARATH:SIS=100:D=Y:B=100]):0.930921[&&NHX:S=Magnoliophyta:D=N:B=100],((((((((((((CCNK_HUMAN:0.001351[&&NHX:S=HUMAN],CCNK_F3_PANTR:0.001588[&&NHX:S=PANTR]):0.009317[&&NHX:S=Homo/Pan/Gorilla_group:D=N:B=100],CCNK_MACMU:0.01227[&&NHX:S=MACMU]):0.020339[&&NHX:S=Catarrhini:D=N:B=100],(CCNK_BOVIN:0.049478[&&NHX:S=BOVIN],CCNK_CANFA:0.076883[&&NHX:S=CANFA]):0.026972[&&NHX:S=Laurasiatheria:D=N:B=97]):0.01376[&&NHX:S=Eutheria:D=N:B=62],(Ccnk_MOUSE:0.018183[&&NHX:S=MOUSE],LOC500715_RAT:0.02728[&&NHX:S=RAT]):0.054247[&&NHX:S=Murinae:D=N:B=100]):0.087752[&&NHX:S=Eutheria:D=N:B=65],CCNK_MONDO:0.069457[&&NHX:S=MONDO]):0.053263[&&NHX:S=Theria:D=N:B=83],NP_001026380_CHICK:0.085022[&&NHX:S=CHICK]):0.059401[&&NHX:S=Amniota:D=N:B=80],CCNK_XENTR:0.175799[&&NHX:S=XENTR]):0.075577[&&NHX:S=Tetrapoda:D=N:B=97],((si_dkey-60a16_F2_BRARE:0.143195[&&NHX:S=BRARE],(CCNK_TETNG:0.142629[&&NHX:S=TETNG],CCNK_F2_GASAC:0.115749[&&NHX:S=GASAC]):0.130837[&&NHX:S=Percomorpha:D=N:B=100]):0.077038[&&NHX:S=Clupeocephala:D=N:B=95],ENSGACT00000017400_GASAC:0.40355[&&NHX:S=GASAC]):0.058401[&&NHX:S=Clupeocephala:SIS=33:D=Y:B=13]):0.233994[&&NHX:S=Euteleostomi:D=N:B=18],(ENSCINT00000017473_CIOIN:0[&&NHX:S=CIOIN],ENSCINT00000026852_CIOIN:0.002343[&&NHX:S=CIOIN]):0.481407[&&NHX:S=CIOIN:SIS=100:D=Y:B=100]):0.090892[&&NHX:S=Chordata:D=N:B=98],((CycK-RA_DROME:0.17719[&&NHX:S=DROME],dper_GLEANR_8777_caf1_DROPE:0.174477[&&NHX:S=DROPE]):0.199588[&&NHX:S=Sophophora:D=N:B=100],(AAEL013531-RA_AEDAE:0.214131[&&NHX:S=AEDAE],XP_317464_ANOGA:0.204436[&&NHX:S=ANOGA]):0.178396[&&NHX:S=Culicidae:D=N:B=100]):0.293157[&&NHX:S=Diptera:D=N:B=100]):0.104694[&&NHX:S=Coelomata:D=N:B=98],Smp_130980_SCHMA:0.624197[&&NHX:S=SCHMA]):0.041513[&&NHX:S=Bilateria:D=N:B=84],(WBGene00009650_CAEEL:0.186775[&&NHX:S=CAEEL],(CBG04574_CAEBR:0.21279[&&NHX:S=CAEBR],cr01.sctg48.wum.67.1_CAERE:0.192611[&&NHX:S=CAERE]):0.076335[&&NHX:S=Caenorhabditis:D=N:B=86]):1.18006[&&NHX:S=Caenorhabditis:D=N:B=86]):0.311276[&&NHX:S=Bilateria:D=N:B=84])[&&NHX:S=Eukaryota:D=N:B=0];";
        var NEWICK = null;
        var temp_tree = null;
        var METADATA = null;
        var TABLE_HEADERS = null;
        var data_table = null;
        var original_data = null;
        var query_table = null;
        var ORIGINAL_DATA = null;
        var ORIGINAL_VIEW_BOX = null;
        var LAST_MOVE_X = 0;
        var LAST_MOVE_Y = 0;
        const default_color = "#999";
        const clicked_color = "red";
        const ID_FIELD = 0;
        const SELECTED_NODES = new Set();

        /** Code for parsing a newick tree to be used by D3
         * The code is taken from Knhx.js written by Heng Li
        */
        function kn_new_node() { // private method
            // Heng li code to add node
            return {parent:null, children:[], name:"", meta:"", d:-1.0, hl:false, hidden:false};
        }

        function kn_add_node(str, l, tree, x) // private method
        {
            // Heng Li code to add nodes to a tree
            var r, beg, end = 0, z;
            z = kn_new_node();
            for (i = l, beg = l; i < str.length && str.charAt(i) != ',' && str.charAt(i) != ')'; ++i) {
                var c = str.charAt(i);
                if (c == '[') {
                    var meta_beg = i;
                    if (end == 0) end = i;
                    do ++i; while (i < str.length && str.charAt(i) != ']');
                    if (i == str.length) {
                        tree.error |= 4;
                        break;
                    }
                    z.meta = str.substr(meta_beg, i - meta_beg + 1);
                } else if (c == ':') {
                    if (end == 0) end = i;
                    for (var j = ++i; i < str.length; ++i) {
                        var cc = str.charAt(i);
                        if ((cc < '0' || cc > '9') && cc != 'e' && cc != 'E' && cc != '+' && cc != '-' && cc != '.')
                            break;
                    }
                    z.d = parseFloat(str.substr(j, i - j));
                    --i;
                } else if (c < '!' && c > '~' && end == 0) end = i;
            }
            if (end == 0) end = i;
            if (end > beg) z.name = str.substr(beg, end - beg);
            tree.node.push(z);
            return i;
        }
    
        function kn_parse(str)
            {
                // Heng li Newick parsing code
            var stack = new Array();
            var tree = new Object();
            tree.error = tree.n_tips = 0;
            tree.node = new Array();
            for (var l = 0; l < str.length;) {
                while (l < str.length && (str.charAt(l) < '!' || str.charAt(l) > '~')) ++l;
                if (l == str.length) break;
                var c = str.charAt(l);
                if (c == ',') ++l;
                else if (c == '(') {
                    stack.push(-1); ++l;
                } else if (c == ')') {
                    var x, m, i;
                    x = tree.node.length;
                    for (i = stack.length - 1; i >= 0; --i)
                        if (stack[i] < 0) break;
                    if (i < 0) {
                        tree.error |= 1; break;
                    }
                    m = stack.length - 1 - i;
                    l = kn_add_node(str, l + 1, tree, m);
                    for (i = stack.length - 1, m = m - 1; m >= 0; --m, --i) {
                        tree.node[x].children[m] = tree.node[stack[i]];
                        tree.node[stack[i]].parent = tree.node[x];
                    }
                    stack.length = i;
                    stack.push(x);
                } else {
                    ++tree.n_tips;
                    stack.push(tree.node.length);
                    l = kn_add_node(str, l, tree, 0);
                }
            }
            if (stack.length > 1) tree.error |= 2;
            tree.root = tree.node[tree.node.length - 1];
            return tree;
        }
        //~~~~~~~~~ End of Heng Li's Code

        

        /// D3 code related to zooming (thanks again Mike)
        //let zoomed = ({transform}) => {
        //    //$("g").attr("transform", transform);
        //    $("g path").attr("transform", transform);
        //};



        // D3.js Tidy Tree code
        // Modified but taken from: https://observablehq.com/@d3/collapsible-tree
        // Specify the charts’ dimensions. The height is variable, depending on the layout.
        chart = (data) => {
                // Specify the charts’ dimensions. The height is variable, depending on the layout.
                //console.log(window.innerWidth);
                //console.log(window.innerHeight);
                //const width = 2000;
                const width = window.innerWidth;
                const marginTop = 40;
                const marginRight = 10;
                const marginBottom = 10;
                const marginLeft = 40;

                // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
                // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
                // “bottom”, in the data domain. The width of a column is based on the tree’s height.
                const root = d3.hierarchy(data);
                const dx = 20;
                const dy = (width - marginRight - marginLeft) / (1 + root.height);

                // Define the tree layout and the shape for links.
                const tree = d3.tree().nodeSize([dx, dy]);
                const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

                // Create the SVG container, a layer for the links and a layer for the nodes.
                const svg = d3.create("svg")
                    .attr("id", "TreeSVG")
                    .attr("width", width)
                    .attr("height", dx)
                    .attr("viewBox", [-marginLeft, -marginTop, width, dx])
                    .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif; user-select: none;");

                const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.4)
                    .attr("stroke-width", 1.5);

                const gNode = svg.append("g")
                    .attr("cursor", "pointer")
                    .attr("pointer-events", "all");

                function update(event, source) {
                    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                    const nodes = root.descendants().reverse();
                    const links = root.links();

                    // Compute the new tree layout.
                    tree(root);

                    let left = root;
                    let right = root;
                    root.eachBefore(node => {
                        if (node.x < left.x) left = node;
                        if (node.x > right.x) right = node;
                    });



                    const height = right.x - left.x + marginTop + marginBottom;
                    const transition = svg.transition()
                        .duration(duration)
                        .attr("height", height)
                        .attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
                        .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));
                    
                    //svg.call(d3.zoom()
                    //    .extent([[0, 0], [width, height]])
                    //    .scaleExtent([1, 8])
                    //    .on("zoom", zoomed));
                    
                    //svg.call(d3.zoom().on("zoom", () => {
                    //    svg.attr("transform", d3.event.transform)
                    //}));
                    


                    // Update the nodes…
                    const node = gNode.selectAll("g")
                        .data(nodes, d => d.id);

                    // Enter any new nodes at the parent's previous position.
                    const nodeEnter = node.enter().append("g")
                        .attr("transform", d => `translate(${source.y0},${source.x0})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0)
                        .attr("id", (d) => {
                            if(d.data.name){
                                return d.data.name;
                            }
                        })
                        .attr("class", "tree-node")
                        .on("click", (event, d) => {
                            d.children = d.children ? null : d._children;
                            let circle_pos = 1;
                            let trg_name_pos = 0;
                            let parent = event.target.closest('g');
                            let trg = parent.childNodes[circle_pos];
                            let node_name = parent.childNodes[trg_name_pos].innerHTML;
                            if(!d._children){
                                // TODO append these to a stack or pop from it if it is not clicked
                                if(trg.style.fill === clicked_color){
                                    trg.style.fill = default_color;
                                    SELECTED_NODES.delete(node_name);
                                }else{
                                    trg.style.fill = clicked_color;
                                    SELECTED_NODES.add(node_name);
                                }
                            }
                            updated_nodes();
                            update(event, d);
                        });

                    nodeEnter.append("circle")
                        .attr("r", 2.5)
                        .attr("fill", d => d._children ? "#555" : "#999")
                        .attr("stroke-width", 10);

                    nodeEnter.append("text")
                        .attr("dy", "0.31em")
                        .attr("x", d => d._children ? -6 : 6)
                        .attr("text-anchor", d => d._children ? "end" : "start")
                        .text(d => d.data.name)
                        .clone(true).lower()
                        .attr("stroke-linejoin", "round")
                        .attr("stroke-width", 3)
                        .attr("stroke", "white");

                    // Transition nodes to their new position.
                    const nodeUpdate = node.merge(nodeEnter).transition(transition)
                        .attr("transform", d => `translate(${d.y},${d.x})`)
                        .attr("fill-opacity", 1)
                        .attr("stroke-opacity", 1);

                    // Transition exiting nodes to the parent's new position.
                    const nodeExit = node.exit().transition(transition).remove()
                        .attr("transform", d => `translate(${source.y},${source.x})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0);

                    // Update the links…
                    const link = gLink.selectAll("path")
                        .data(links, d => d.target.id);

                    // Enter any new links at the parent's previous position.
                    const linkEnter = link.enter().append("path")
                        .attr("d", d => {
                            const o = {x: source.x0, y: source.y0};
                            return diagonal({source: o, target: o});
                        });

                    // Transition links to their new position.
                    link.merge(linkEnter).transition(transition)
                        .attr("d", diagonal);

                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition(transition).remove()
                        .attr("d", d => {
                            const o = {x: source.x, y: source.y};
                            return diagonal({source: o, target: o});
                        });

                    // Stash the old positions for transition.
                    root.eachBefore(d => {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                }

                // Do the first update to the initial configuration of the tree — where a number of nodes
                // are open (arbitrarily selected as the root, plus nodes with 7 letters).
                root.x0 = dy / 2;
                root.y0 = 0;
                root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
                // ! Removed below block to open the whole tree at once
                //if (d.depth && d.data.name.length !== 7) d.children = null;
                //if (d.depth && d.data.name.length !== 7) d.children = null;
                });
                
                update(null, root);
                return svg.node();
            }
        // ~~~~~~ End of D3.js copy pasted code


        var updated_nodes = () => {
            $("#SelectedNodes").html(function(){
                let attribute = "";
                // TODO need to add event listener so that when list values are clicked they are removed
                for(const item of SELECTED_NODES.keys()){
                    attribute = attribute + `<li class="selected-node">${item}</li>\n`;
                }
                attribute = '<ul class="selected-nodes">' + attribute + "</ul>";
                return attribute;
            });
        };

        var drawTree = (newick_) => {
            let tree = kn_parse(newick_);
            let node_out = chart(tree.root);
            $("#TreeData").append(node_out);
            // For resetting the view
            //ORIGINAL_VIEW_BOX = svg[0].getBoundingClientRect();
        };

        let CreateDataTable = () => {
            data_table = $('#metadata').DataTable({
                stateSave: true,
                className: ".editable",
                // TODO this can be initialized as the table is made
                // TODO need to add a mandatory sample_id field and make it non-editable 
                //"createdRow": function(row, data, dataIndex){
                //    var editableCells = $(row).find('.editable');
                //    editableCells.attr('contenteditable', true);
                //    editableCells.on('blur', function(){
                //        var cell = $(this);
                //        var newValue = cell.text();
                //        var columnIndex = cell.index();
                //        var rowData = dataTable.row(cell.closest('tr')).data();
                //        rowData[columnIndex] = newValue;
                //        dataTable.row(cell.closest('tr')).data(rowData).draw();
                //        // Need to add call to update the backend here, I used chatGPT to write the initial part, as I had no idea what I was doing
                //    });
                //}
            });
            // TODO initializing table from json object would minimize copies
            $("td").addClass("editable");
            $("td:not(.sorting_1)").attr("contenteditable", true);
            // Saving data as a map, to allow for updating of metadata
            ORIGINAL_DATA = new Map();
            data_table.rows().data().each((value, index) => {
                ORIGINAL_DATA.set(value[ID_FIELD], value)
            });
        };

        let CreateTable = (parsed_data, table_id, table_headers) => {
            let headers = table_headers;
            let table_head = "";
            let table_body = [];
            for(const item of headers){
                table_head = table_head + `<th>${item}</th>\n`;
            }
            for(const item of parsed_data){
                table_body.push('<tr>\n');
                for(const header of headers){
                    table_body.push(`<td class="editable">${item[header]}</td>\n`);
                }
                table_body.push("</tr>\n");
            }
            //delete parsed_data;
            parsed_data = null;
            $(table_id).html("<thead>" + table_head + "</thead>" + "<tbody>" + table_body.join() + "</tbody>");
            CreateDataTable();
        };

        let CreateQueryTable = () => {

            if(SELECTED_NODES.size === 0){
                console.log("No nodes selected!");
                if($.fn.DataTable.isDataTable('#query-data')){
                    // If selections are empty remove the table
                    // Thank you SO for this: https://stackoverflow.com/questions/32713612/jquery-datatables-destroy-re-create
                    $('#query-data').DataTable().destroy();
                    $("#query-data tbody").empty()
                    $("#query-data thead").empty()
                };
                return null;
            }

            let indices = [];
            let data_columns = []
            for(const item of TABLE_HEADERS){
                data_columns.push({title: item});
            }

            data_table.column(ID_FIELD).data().map((value, idx) => {
                if(SELECTED_NODES.has(value)){
                    indices.push(idx);
                }
            });
            // TODO this could be made more performant by check what is new in the set and only getting that data and appending it to the table
            // TODO clearing and adding could be added and would then only require initializing the datatable once
            let selected_data = data_table.rows( indices ).data().toArray();
            if($.fn.DataTable.isDataTable('#query-data')){
                // TODO probably faster to clear the table then add rows
                $('#query-data').DataTable().destroy();
                $("#query-data tbody").empty()
                $("#query-data thead").empty()
            };

            query_table = new DataTable("#query-data", {
                columns: data_columns,
                data: selected_data
            });
        };

        let ResetTable = () => {
            data_table.clear();
            // Is there a more space efficient way to do this?
            // TODO perhaps metadata from d3 can be used here
            data_table.rows.add(Array.from(ORIGINAL_DATA.values())).draw();
            $("td").addClass("editable");
            $("td:not(.sorting_1)").attr("contenteditable", true);
        };

        let SubsetTable = () => {
            let filtered = data_table.data().filter((value, idx) => {
                return SELECTED_NODES.has(value[ID_FIELD]);
            });
            data_table.clear();
            data_table.rows.add(filtered).draw();
            $("td").addClass("editable");
            $("td").attr("contenteditable", true);

        };


        $(() => {

            $("#tree-selector").change((event) => {
                let reader = new FileReader();
                let newick_file = event.target.files[0];
                reader.readAsText(newick_file, "UTF-8");
                reader.onload = (evt) => {
                    newick = evt.target.result;
                    drawTree(newick);
                };
                reader.onerror = (evt) => {
                    alert(`Could not read file ${newick_file}`);
                };
            });

            $("#ResetTree").on("click", (evt) => {
                let svg = $("#TreeSVG");
                let og_box = svg[0].getBBox();
                svg.attr("viewBox", `${og_box.x + og_box.x} ${og_box.y} ${og_box.width} ${og_box.height}`);
            });

            // TODO look up alternative to blur, as only when content is changed does a look up need to be done
            $("#metadata").on("blur", ".editable", (evt)=>{
                // This gives me elemet to look for, just need to update original element with it
                // TODO alter original elements here
                let row_values = evt.target.closest("tr").childNodes;
                console.log(row_values);
                let edited_value = row_values[0].textContent;
                let retrieved_value = ORIGINAL_DATA.get(edited_value);
                for(let i = 0; i < retrieved_value.length; i++){
                    retrieved_value[i] = row_values[i].textContent;

                }
            });

            $("#metadata-selector").change((event) => {
                let reader = new FileReader();
                let metadata_file = event.target.files[0];
                reader.readAsText(metadata_file, "UTF-8");
                reader.onload = (evt) => {
                    let metadata = evt.target.result;
                    METADATA = d3.tsvParse(metadata);
                    TABLE_HEADERS = METADATA.columns;
                    CreateTable(METADATA, "#metadata", TABLE_HEADERS);
                    METADATA = null;
                };
                reader.onerror = (evt) => {
                    alert(`Could not read file ${metadata_file}`);
                };
            });

            //$("#metadata-search-button").on('click', CreateQueryTable);
            $("#metadata-search-button").on('click', SubsetTable);
            $("#reset-table-button").on('click', ResetTable);

            $("#metadata").on('dblclick', '.sorting_1', (evt) => {

                let identified_point = $(`.tree-node#${evt.target.textContent}`)
                console.log(identified_point[0]);
                let rect = identified_point[0].getBBox();
                let translated_coords = identified_point[0].getAttribute('transform').replace('translate(', '').replace(")", '').split(",");
                let rect_x = parseFloat(translated_coords[0]);
                let rect_y = parseFloat(translated_coords[1]);
                let svg = $("#TreeSVG");
                let og_box = svg[0].getBBox()
                let new_view = "" + ((rect.x + rect_x) - (og_box.width * 0.15)) + " " + ((rect.y + rect_y ) - (og_box.height * 0.02)) + " " + og_box.width * 0.5 + " " + og_box.height * 0.5;
                svg.attr("viewBox", new_view);
            });


            $("#SelectedNodes").on('dblclick', '.selected-node', (evt) => {
                let node_name = evt.target.textContent;
                SELECTED_NODES.delete(node_name);
                let unselected_data = $(`g #${node_name}`).children();
                unselected_data[1].style.fill = default_color;
                updated_nodes();
            });

            $("#TreeData").on('scroll', '#TreeSVG', (evt) => {
                console.log("scrolling");
            });
        });



    </script>
</head>
    <body>
        <div>
            <label for="tree-selector">Select a Newick File </label>
            <input type="file" id="tree-selector" name="tree-selector" accept=".nwk, .newick, .treefile"> 
        </div>
        <div>
            <label for="metadata-selector">Select a tab delimited metadata file</label>
            <input type="file" id="metadata-selector" name="metadata-selector" accept=".tsv, .tab">
        </div>
        <div class="TreeSelections" id="TreeSelections" style="width:100%">
            <!--<div class="Tree inline-block-child scrollbar-window" id="TreeData" style="height:500px;"></div>-->
            <button name="ResetTree" id="ResetTree">Reset Tree View</button>
            <div class="Tree inline-block-child scrollbar-window" id="TreeData" style="width:80%;height:50vh;float:left"></div>
            <button name="SearchMetadata" id="metadata-search-button">Search Metadata</button>
            <button name="SearchMetadata" id="reset-table-button">Reset Table</button>
            <div class="Tree inline-block-child scrollbar-window" id="SelectedNodes" style="height:50vh;width:20%;float:right"></div>
        </div>

        <div id="ClusterInfo" style="padding-top:0px;">
            <table id="metadata" class="display" style="width:100%; height:50vh"></table>
        </div>
    </body>
</html>